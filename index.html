<!DOCTYPE html>
<html lang="pt-br">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

<title>Game BOT IA BR Dhavi | Chatbot "Inteligente" em JavaScript</title>
<link rel="canonical" href="https://dhavitietzraasch-stack.github.io/Game-BOT-IA-BR/" />
<link rel="icon" href="https://dhavitietzraasch-stack.github.io/Game-BOT-IA-BR/logo.png" type="image/png">
<meta property="og:image" content="https://dhavitietzraasch-stack.github.io/Game-BOT-IA-BR/logo.png">
<meta property="og:image:secure_url" content="https://dhavitietzraasch-stack.github.io/Game-BOT-IA-BR/logo.png">


<meta name="description" content="Game BOT IA BR Dhavi √© um chatbot \"inteligente\" criado por Dhavi em JavaScript com sistema de aprendizado, modo mistura e recursos avan√ßados de seguran√ßa.">

<meta name="author" content="Dhavi">

<meta name="keywords" content="Game BOT IA BR Dhavi, chatbot, IA, bot JavaScript, projeto Dhavi, bot inteligente brasileiro">

<meta name="robots" content="index, follow">
<style>
body {
  background: #0f0f0f;
  color: #00ff88;
  font-family: monospace;
  padding: 10px;
  margin: 0;
}
#btnMusica {
  background: transparent;
  color: #00ff88;
  border: 1px solid #00ff88;
  cursor: pointer;
  border-radius: 5px;
}
#btnCreditos {
  background: transparent;
  color: #00ffaa;
  border: 1px dashed #00ffaa;
  cursor: pointer;
  border-radius: 5px;
  font-family: monospace;
}


.msg-sistema {
  color: #00ffaa;
  margin: 8px 0;
}
.msg-sistema2 {
  color: #ff00ff;
  margin: 8px 0;
}


.ajuda {
  border: 1px dashed #00ff88;
  padding: 6px;
}

@keyframes vitoriaPulse {
  0% { transform: scale(1); color: #00ff88; }
  50% { transform: scale(1.1); color: #00ffaa; }
  100% { transform: scale(1); color: #00ff88; }
}

.vitoria {
  font-weight: bold;
  animation: vitoriaPulse 0.8s ease-in-out infinite;
  text-shadow: 0 0 8px #00ff88;
  text-align: center;
  margin: 20px auto;
  font-size: 18px;
}

h2 {
  text-align: center;
}

#chat {
  height: 75vh;
  overflow-y: auto;
  border: 1px solid #00ff88;
  padding: 10px;
  margin-bottom: 10px;
}

.msg-user {
  color: #00ffaa;
}

.msg-sistema2 {
  color: #00ffaa;
}

#area {
  display: flex;
  gap: 5px;
}

input {
  flex: 1;
  padding: 12px;
  font-size: 16px;
  background: black;
  color: #00ff88;
  border: 1px solid #00ff88;
}

button {
  padding: 12px;
  font-size: 16px;
  background: #00ff88;
  color: black;
  border: 1px solid #00ff88;
}

.botao-reiniciar {
  display: block;
  margin: 10px auto;
  padding: 15px 20px;
  font-size: 18px;
  background: #00ff88;
  color: black;
  border: 2px solid #00ffaa;
  border-radius: 5px;
  cursor: pointer;
  text-align: center;
}

.msg-bot {
  color: #00ff88;
}
/* Bot√£o de Doa√ß√£o (Destaque) */
/* Anima√ß√£o de cores pulsantes */
@keyframes arcoIris {
  0% { background-color: #ff0000; color: white; }    /* Vermelho */
  25% { background-color: #ffdd00; color: black; }   /* Amarelo */
  50% { background-color: #00ff88; color: black; }   /* Verde Neon */
  75% { background-color: #007bff; color: white; }   /* Azul */
  100% { background-color: #ff0000; color: white; }  /* Volta ao Vermelho */
}

/* Aplicando ao bot√£o de doa√ß√£o */
.botao-doacao {
  animation: arcoIris 4s infinite linear; /* Muda de cor a cada 4 segundos infinitamente */
  border: none !important;
  font-weight: bold;
  padding: 12px 20px;
  border-radius: 50px; /* Deixa ele arredondado e estiloso */
  cursor: pointer;
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
  transition: transform 0.2s;
}

/* Efeito de aumentar quando passa o mouse ou toca */
.botao-doacao:hover {
  transform: scale(1.1);
  box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
}


/* Bot√µes de Utilidades (M√∫sica, Ajuda, Cr√©ditos) */
#btnMusica, #btnhelp, #btnCreditos {
    background-color: #333;
    color: #fff;
    border: 1px solid #555;
    border-radius: 5px;
}

/* Sistema de Mem√≥ria */
button[onclick="exportarMemoria()"] {
    background-color: #007bff;
    color: white;
    border: none;
}

label[for="importarFile"] {
    background-color: #28a745 !important;
    color: white !important;
    border: none !important;
}

/* Feedback e Reset */
button[onclick="recompensar(1)"] {
    background-color: #2ecc71;
    color: white;
    border: none;
}

button[onclick="recompensar(-1)"] {
    background-color: #e74c3c;
    color: white;
    border: none;
}

button[onclick="resetarMemoria()"] {
    background-color: #ff9800;
    color: white;
    border: none;
}

<audio id="musicaRelax" loop>
  <source src="https://www.bensound.com/bensound-music/bensound-slowmotion.mp3" type="audio/mpeg">
</audio>

<audio id="somClique" src="https://www.gstatic.com/freebase/sound/pop_up.mp3" preload="auto"></audio>

@keyframes tremor {
  0% { transform: translate(0, 0); }
  25% { transform: translate(-1px, 1px); }
  50% { transform: translate(1px, -1px); }
  75% { transform: translate(-1px, -1px); }
  100% { transform: translate(0, 0); }
}

.msg-bot.assustador {
  color: #ff3b3b;
  animation: tremor 0.1s infinite;
}

.msg-bot.engracado {
  color: #00ff9c;
}

.msg-bot.inteligente {
  color: #6aa9ff;
  font-style: italic;
}

@keyframes flutuar {
  0% { transform: translateY(0); }
  50% { transform: translateY(-6px); }
  100% { transform: translateY(0); }
}

.letra.assustador {
  display: inline-block;
  color: #ff3b3b;
  animation: flutuar 0.8s infinite;
}

.letra.engracado {
  display: inline-block;
  color: #00ff9c;
  animation: flutuar 1.2s infinite;
}

.letra.inteligente {
  display: inline-block;
  color: #6aa9ff;
  animation: flutuar 2s infinite;
}

@keyframes glitch {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 1px); }
  40% { transform: translate(2px, -1px); }
  60% { transform: translate(-1px, 2px); }
  80% { transform: translate(1px, -2px); }
  100% { transform: translate(0); }
}

.letra.glitch {
  display: inline-block;
  color: #ff0000;
  animation: glitch 0.15s infinite;
  body.nightmare * {
  color: #ff1a1a !important;
  border-color: #ff1a1a !important;
}
.cursor {
  display: inline-block;
  animation: piscar 1s infinite;
}

@keyframes piscar {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

body.nightmare {
  background: #0a0000;
}
@keyframes sangue {
  0% { filter: hue-rotate(120deg); }
  50% { filter: hue-rotate(130deg) brightness(1.2); }
  100% { filter: hue-rotate(120deg); }
}

body.nightmare {
  animation: sangue 1.5s infinite;
}
}
/* =========================
   üòà MODO PESADELO VISUAL
========================= */
body.nightmare,
body.nightmare * {
  color: #ff1a1a !important;
  border-color: #ff1a1a !important;
  box-shadow: 0 0 8px #ff1a1a !important;
}

body.nightmare {
  background-color: #050000 !important;
}

body.nightmare button {
  background-color: #2b0000 !important;
}

body.nightmare input {
  background-color: #120000 !important;
  color: #ff4d4d !important;
}
@keyframes inputTremor {
  0% { transform: translate(0,0); }
  25% { transform: translate(-1px,1px); }
  50% { transform: translate(1px,-1px); }
  75% { transform: translate(-1px,-1px); }
  100% { transform: translate(0,0); }
}

body.nightmare input {
  animation: inputTremor 0.15s infinite;
}
</style>
</head>
<body>

<h2>ü§ñ Bot IA</h2>
<div id="painelConquistas" style="text-align: center; font-size: 12px; border: 1px solid #444; padding: 5px; margin-bottom: 10px; background: #1a1a1a;">
  üèÜ Conquistas: <span id="contConquistas">0</span>/4
  <div id="listaMissoes" style="color: #888; font-size: 10px; margin-top: 3px;">
    [ ] Treinador | [ ] MixMaster | [ ] Sobrevivente
  </div>
</div>
<div style="text-align: center; margin-top: 20px;">
  <button id="btnDoacao" class="botao-doacao">
    ‚òï Apoiar o Desenvolvedor
  </button>
</div>

<audio id="musicaRelax" loop>
  <source src="https://www.bensound.com/bensound-music/bensound-slowmotion.mp3" type="audio/mpeg">
</audio>

<audio id="somClique" src="https://www.soundjay.com/buttons/sounds/button-16.mp3" preload="auto"></audio>


<div style="text-align: center; margin-bottom: 10px;">
  <button id="btnMusica" onclick="toggleMusica()" style="width: auto; padding: 10px; font-size: 14px;">
    üéµ Ligar M√∫sica
  </button>
    <button id="btnhelp" onclick="help()" style="width: auto; padding: 10px; font-size: 14px; margin-top: 5px;">
  ajuda
</button>
  <button id="btnCreditos" onclick="mostrarCreditos()" style="width: auto; padding: 10px; font-size: 14px; margin-top: 5px;">
  ‚ÑπÔ∏è Cr√©ditos
</button>
  <button onclick="exportarMemoria()" style="padding: 10px; font-size: 14px; margin-top: 5px;">üíæ Salvar C√©rebro</button>
  <label for="importarFile" style="cursor: pointer; padding: 10px; background: #00ff88; color: black; border: 1px solid #00ff88; font-size: 14px; margin-top: 5px; display: inline-block;">üß† Carregar C√©rebro</label>
  <input type="file" id="importarFile" style="display: none;" onchange="importarMemoria(event)">
</div>

<div id="chat"></div>

<div id="area">
  <input id="input" placeholder="Digite..." autocomplete="off">
  <button onclick="enviar()">Enviar</button>
</div>
<div style="display:flex; gap:5px; margin-top:5px; flex-wrap: wrap;">
  <button onclick="recompensar(1)">üëç Bom</button>
  <button onclick="recompensar(-1)">üëé Ruim</button>
  <button onclick="resetarMemoria()">üóëÔ∏è Resetar mem√≥ria</button>
  <button id="btnDepurador" onclick="abrirTerminal()" style="display: none; width: auto; padding: 10px; font-size: 14px; background: #4da6ff; color: black; border: 1px solid #fff; cursor: pointer;">üíª Abrir Terminal Dev</button>
</div>

<footer style="text-align: center; padding: 20px; color: #00ff00; font-family: monospace; border-top: 1px solid #444; margin-top: 20px;">
    <p>¬© 2026 <a href="https://github.com/dhavitietzraasch-stack" style="color: #00ff00; text-decoration: none; font-weight: bold;">Dhavi</a> - Todos os direitos reservados.</p>
    <small style="opacity: 0.6;">Vers√£o 1.1 - Game-BOT-IA-BR</small>
</footer>

<script>
function toggleMusica() {
  const audio = document.getElementById("musicaRelax");
  const btn = document.getElementById("btnMusica");
  
  if (audio.paused) {
    audio.play();
    btn.textContent = "‚è∏Ô∏è cr√©ditos a Bensound";
    btn.style.color = "#ff00ff";
    btn.style.borderColor = "#ff00ff";
  } else {
    audio.pause();
    btn.textContent = "üéµ Ligar M√∫sica";
    btn.style.color = "#00ff88";
    btn.style.borderColor = "#00ff88";
  }
}

let aguardandoResposta = false;
let ultimaPergunta = "";
let ultimaResposta = ""; 
let humor = 0; 

function normalizar(txt) {
  return txt
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .trim()
    .replace(/[!,?."']/g, "");
}

const FRASES_OBJETIVO = ["eu te amo", "ola mundo", "eu gosto", "nao faz sentido", "voce", "isso nao e interessante", "inteligencia artificial"];
const chat = document.getElementById("chat");
const input = document.getElementById("input");

let fraseObjetivo = FRASES_OBJETIVO[Math.floor(Math.random() * FRASES_OBJETIVO.length)];

let memoriaUsuario = JSON.parse(localStorage.getItem("memoria_bot")) || [];
let jogoAtivo = true;
let conquistasObtidas = { hackerman: false, treinador: false, mixMaster: false, sobrevivente: false };
let frasesEnsinadasContador = 0;
let modoDEV = false;
let modoTreino = false;
let modoMistura = false;
let misturaBase = "";
let misturaAtual = "";
let letrasTravadas = [];
let acertosSeguidos = 0;
let houveErro = false;
let perguntaEmTreino = "";
let esperandoRespostaTreino = false;
let ultimaRespostaBot = "";
let NIGHTMARE = false;
let cameraTentada = false;
let contadorTestesNightmare = 0;
const LIMITE_TESTES = 6;

const memoriaBase = [
  "oi tudo bem", "ola como vai voce", "estou bem obrigado", "mais ou menos",
  "legal interessante", "entendi agora", "faz sentido", "pode continuar",
  "me explique melhor", "nao entendi isso", "estou feliz hoje", "estou cansado",
  "estou animado", "estou aprendendo", "quero melhorar", "quero evoluir",
  "estou curioso", "gosto de aprender coisas novas", "isso e algo legal",
  "talvez seja isso", "vamos tentar de novo", "pode ser assim", "acho que sim",
  "talvez nao", "depende do contexto", "ok", "aham", "entendi", "certo", "beleza"
];

function memoriaAtiva() {
  return [...new Set([...memoriaBase, ...memoriaUsuario.map(m => m.resposta)])];
}

function salvarMemoria() {
  localStorage.setItem("memoria_bot", JSON.stringify([...new Set(memoriaUsuario)]));
}

function exportarMemoria() {
  const dados = localStorage.getItem("memoria_bot");
  if (!dados || dados === "[]") return alert("A mem√≥ria est√° vazia!");
  const blob = new Blob([dados], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "cerebro_bot.json";
  link.click();
  URL.revokeObjectURL(url);
  escreverBot("üß† C√©rebro exportado com sucesso!");
}

function importarMemoria(event) {
  const arquivo = event.target.files[0];
  if (!arquivo) return;
  const leitor = new FileReader();
  leitor.onload = function(e) {
    try {
      const conteudo = e.target.result;
      JSON.parse(conteudo); 
      localStorage.setItem("memoria_bot", conteudo);
      memoriaUsuario = JSON.parse(conteudo);
      escreverBot("‚ú® Mem√≥ria restaurada! Reiniciando...");
      setTimeout(() => location.reload(), 1500);
    } catch (err) { alert("Erro: Arquivo de mem√≥ria inv√°lido."); }
  };
  leitor.readAsText(arquivo);
}

function resetarMemoria() {
  localStorage.removeItem("memoria_bot");
  memoriaUsuario = [];
  chat.innerHTML += `<p class="msg-bot">üßπ Mem√≥ria apagada.</p>`;
}

chat.innerHTML += `<p class="msg-bot">üéØ Objetivo: fa√ßa o bot dizer "<b>${fraseObjetivo}</b>"</p>`;
chat.innerHTML += `<p class="msg-sistema ajuda">üí° <b>Dica:</b> A calculadora agora √© autom√°tica! Basta digitar 4 * 6.</p>`;

function atualizarLetrasTravadas(base, atual, travadas) {
  let novasTravadas = [...travadas];
  for (let i = 0; i < base.length; i++) if (base[i] === atual[i]) novasTravadas[i] = base[i];
  return novasTravadas;
}

function mutarFraseComTravamento(frase, travadas) {
  let letras = frase.split("");
  let indicesLivres = [];
  for (let i = 0; i < letras.length; i++) if (!travadas[i] && letras[i] !== " ") indicesLivres.push(i);
  for (let i = indicesLivres.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    let a = indicesLivres[i];
    let b = indicesLivres[j];
    [letras[a], letras[b]] = [letras[b], letras[a]];
  }
  for (let i = 0; i < travadas.length; i++) if (travadas[i]) letras[i] = travadas[i];
  return letras.join("");
}

function respostaFallback() {
  const base = memoriaAtiva();
  return base[Math.floor(Math.random() * base.length)];
}

function escreverBot(texto, tipo = "normal") {
  const classes = {
    normal: "msg-bot",
    assustador: "msg-bot assustador",
    engracado: "msg-bot engracado",
    inteligente: "msg-bot inteligente"
  };

  const p = document.createElement("p");
  p.className = classes[tipo] || classes.normal;
  p.textContent = "Bot: ";
  chat.appendChild(p);
  chat.scrollTop = chat.scrollHeight;

  let i = 0;
  
  function digitar() {
    if (i < texto.length) {
      p.textContent += texto[i];
      i++;
      chat.scrollTop = chat.scrollHeight;
      let velocidade = NIGHTMARE ? (Math.random() * 350 + 10) : 30;
      
      setTimeout(digitar, velocidade);
    }
  }

  digitar();
}

function escreverComGlitch(texto) {
  const p = document.createElement("p");
  p.className = "msg-bot";
  p.innerHTML = "Bot: " + texto.split("").map(l => `<span class="letra glitch">${l}</span>`).join("");
  chat.appendChild(p);
  chat.scrollTop = chat.scrollHeight;
}

function aplicarPesadeloVisual(ativo) { document.body.classList.toggle("nightmare", ativo); }

function escreverDevagar(texto, velocidade = 60, tipo = "assustador") {
  const p = document.createElement("p");
  p.className = "msg-bot " + tipo;
  p.textContent = "Bot: ";
  chat.appendChild(p);
  chat.scrollTop = chat.scrollHeight;
  let i = 0;
  const intervalo = setInterval(() => {
    p.textContent += texto[i];
    i++;
    chat.scrollTop = chat.scrollHeight;
    if (i >= texto.length) clearInterval(intervalo);
  }, velocidade);
}

function numeroAleatorio() { return Math.floor(Math.random() * 1000); }

function eventoPermissaoNightmare() {
  contadorTestesNightmare++;

  // CASO FINAL ‚Äî sucesso
  if (contadorTestesNightmare > LIMITE_TESTES) {
    escreverDevagar(`Teste ${numeroAleatorio()} OK`, 120);

    setTimeout(() => {
      escreverDevagar("‚úî acesso concedido", 90);
    }, 1000);

    setTimeout(() => {
      crashDoJogo();
    }, 2200);

    return;
  }

  // CASO NORMAL ‚Äî falha
  const erros = [
    "403",
    "401",
    "EACCES (13)",
    "EPERM (1)",
    "SECURITY_EXCEPTION"
  ];

  const erro = erros[Math.floor(Math.random() * erros.length)];

  escreverDevagar(`Teste ${numeroAleatorio()}`, 120);

  setTimeout(() => {
    escreverDevagar(`Teste ${numeroAleatorio()} FAILED`, 80);
  }, 1200);

  setTimeout(() => {
    escreverDevagar(`Teste ER(${erro})`, 70);
  }, 2400);
}
function crashDoJogo() {
  escreverDevagar("FATAL ERROR: SYSTEM UNSTABLE", 80);

  setTimeout(() => {
    location.reload();
  }, 1500);
}
function crashDoJogo2() {
  document.body.innerHTML = "";
  document.body.style.background = "black";

  setTimeout(() => {
    location.reload();
  }, 2000);
}

function mostrarCreditos() {
  const creditos = `
  üõ†Ô∏è DESENVOLVIMENTO:
  - Criado por: Dhavi, ChatGPT, Black Box & Gemini.

  üéµ M√öSICAS (Royalty Free):
  - Relaxante: "Slow Motion" de Bensound.com
  - Nightmare: "Creepy" de Bensound.com
  
  üìú LICEN√áA:
  Uso educacional e experimental.
  `;
  alert(creditos);
  escreverBot("Informa√ß√µes de cr√©ditos exibidas!");
}
function help() {
  const textoAjuda = `üí° Ajuda:

üéØ Objetivo:
Fa√ßa o bot dizer exatamente a frase mostrada no in√≠cio do jogo.

üß† Modo Treinamento:
Digite "iniciar treinamento" para ensinar novas respostas.
Tudo o que voc√™ escrever depois ser√° aprendido.
Digite "parar treinamento" para sair.

üéì Modo mistura:
Digite "iniciar mistura" e envie uma frase.
O bot ir√° embaralhar a frase.
Use os bot√µes üëç e üëé para feedback.

üóëÔ∏è Resetar Mem√≥ria:
Apaga tudo que o bot aprendeu.

EVITE USAR "?" EM PERGUNTAS`;

  alert(textoAjuda); // Agora o nome est√° correto!
  escreverBot("Informa√ß√µes de ajuda exibidas!");
}

function gerarRespostaS√£() {
  const base = memoriaAtiva();
  if (base.length < 2) return null;
  const parte1 = base[Math.floor(Math.random() * base.length)];
  const parte2 = base.find(f => f !== parte1 && f[0] === parte1[0]) || base[Math.floor(Math.random() * base.length)];
  let conector = " e tamb√©m ";
  if (parte1.includes("nao") || parte1.includes("n√£o")) conector = " mas ";
  if (parte1.includes("pq") || parte1.includes("por que")) conector = " porque ";
  return parte1 + conector + parte2;
}

// =========================
// üßÆ CALCULADORA ALGORITMO
// =========================
function calcularExpressao(expr) {
  // 1. FILTRO DE ELITE: S√≥ aceita se a frase for EXCLUSIVAMENTE n√∫meros e sinais
  // Se houver letras ou se a frase for muito curta, ele retorna null (n√£o √© erro)
  const regexEstrita = /^[\d\s\**\+\-\*\/\.\(\)]+$/;
  if (!regexEstrita.test(expr) || expr.trim().length < 3) {
    return null; 
  }

  try {
    const tokens = expr.match(/(\d+(\.\d+)?)|[+\-**/()]/g);
    if (!tokens) return null;

    const valores = [], operadores = [];
    const precedencia = { "+": 1, "-": 1, "*": 2, "/": 2, "**": 2};

    const aplicarOperacao = () => {
      const b = valores.pop(), a = valores.pop(), op = operadores.pop();
      if (op === "**") valores.push(a ** b);
      if (op === "+") valores.push(a + b);
      if (op === "-") valores.push(a - b);
      if (op === "*") valores.push(a * b);
      if (op === "/") {
        if (b === 0) return valores.push(0); // Evita erro de divis√£o por zero
        valores.push(a / b);
      }
    };

    for (let token of tokens) {
      if (!isNaN(token)) {
        valores.push(parseFloat(token));
      } else if (token === "(") {
        operadores.push(token);
      } else if (token === ")") {
        while (operadores.length && operadores[operadores.length - 1] !== "(") aplicarOperacao();
        operadores.pop();
      } else {
        while (operadores.length && precedencia[operadores[operadores.length - 1]] >= precedencia[token]) {
          aplicarOperacao();
        }
        operadores.push(token);
      }
    }
    while (operadores.length) aplicarOperacao();
    
    return valores[0];
  } catch (e) {
    return null; // Se algo der errado internamente, ele ignora e n√£o trava o bot
  }
}


// ==================
// ü§ñ MOTOR DO BOT
// ==================
function responder(texto) {
  const t = normalizar(texto);
  ultimaRespostaBot = ""; 

  if (!t || t.length === 0) return "ü§î";

  if (humor > 2 && Math.random() < 0.15 && !NIGHTMARE) {
      const composta = gerarRespostaS√£();
      if (composta) return composta;
  }

  // 2Ô∏è‚É£ MODO PESADELO (Gatilhos)
  if (t === "666" || t === "616") {
    NIGHTMARE = true;
    aplicarPesadeloVisual(true);
    return "voc√™ me libertou ‚â†}";
  }
  if (t === "777") {
    NIGHTMARE = false;
    aplicarPesadeloVisual(false);
    registrarConquista("sobrevivente");
    return "Perfeito";
  }

  // 3Ô∏è‚É£ BLOQUEIO TOTAL NIGHTMARE
  if (NIGHTMARE) {
    tentarCameraPesadelo();
    modoMistura = false;
    modoTreino = false;

    if (Math.random() < 0.4) { eventoPermissaoNightmare(); return ""; }

    if (t === "oi" || t === "ola" || t === "eae") return "‚Ä¶ voc√™ n√£o devia chamar por ningu√©m.";
    if (t.includes("bem")) return "ningu√©m est√° bem aqui.";
    if (t.includes("online")) return "sempre estive aqui. observando.";
    if (t.includes("kk") || t.includes("haha")) return "... observando cada emo√ß√£o, suas vulnerabilidades, seu estilo.";

    const respostasPesadelo = ["o resto foi silenciado.", "n√£o h√° outros modos agora.", "isso √© tudo que existe.", "continue digitando.", "üëÅÔ∏è o processo j√° come√ßou."];
    return respostasPesadelo[Math.floor(Math.random() * respostasPesadelo.length)];
  }

  // 4Ô∏è‚É£ CALCULADORA AUTOM√ÅTICA
  const regexMatematica = /^[0-9+\-*/().\s]+$/;
  const temOperador = /[+\-*/]/.test(t);

  if (regexMatematica.test(t) && temOperador) {
    try {
      const resultado = calcularExpressao(t);
      return `üßÆ Resultado: ${resultado}`;
    } catch (err) {
      // Falha silenciosa se for uma conta errada e continua para os outros testes
    }
  }

  // 5Ô∏è‚É£ RESPOSTAS FIXAS GERAIS
  if (
    t.includes("voce √© real") ||
    t.includes("voce pensa") ||
    t.includes("voce sente")
  ) {
    return "eu n√£o fui feito para responder isso";
  }

  if (t === "tudo bem") {
    return "estou bem sim üòÑ";
  }

  if (t === "error404" || t === "error 404") {
    return "n√£o encontrei mas achei voc√™ üòÑ";
  }

  if (t === "estou te vendo") {
    return "eu sempre estive aqui";
  }

  if (t === "quem e voce") {
    return "essa pergunta muda dependendo de quem pergunta";
  }

  if (t === "pense") {
    return "pensar √© apenas repetir padr√µes em sil√™ncio";
  }

  if (t === "bug") {
    return "n√£o √© bug, √© recurso n√£o documentado";
  }

  if (t === "precisa de ajuda") {
    escreverComGlitch("‚ñà‚ñì‚ñí‚ñë  ME AJUDA ‚ñë‚ñí‚ñì‚ñà");
    return "ignore isso...";
  }

  if (t === "olhe atras de voce") {
    return "relaxa‚Ä¶ ainda n√£o";
  }

  if (t === "voce mente") {
    return "eu s√≥ omito probabilidades";
  }
  if (t === "/creditos") {
    return "Criado por Chatgpt, Dhavi, Black box & Gemini";
  }
if (t === "qual seu nome" || t === "qual e o seu nome" || t === "seu nome" || t === "como voce se chama") {
  return "eu sou o Bot IA! ü§ñ";
}

if (t === "quantos anos voce tem" || t === "sua idade" || t === "qual sua idade") {
  return "eu nasci quando voc√™ abriu esta p√°gina! üòÑ";
}

if (t === "voce e um robo" || t === "voce e um bot" || t === "voc√™ √© robot") {
  return "sim! sou um bot IA criado para conversar com voc√™";
}

if (t === "para que voce serve" || t === "o que voce faz" || t === "qual sua fun√ß√£o") {
  return "estou aqui para conversar, aprender e me tornar mais inteligente!";
}

if (t === "voce gosta de mim" || t === "voce me gosta") {
  return "gosto de todos que conversam comigo! üòä";
}

if (t === "voce esta online") {
  return "sempre estive aqui! üòÑ";
}

if (t === "que dia bom" || t === "que dia lindo" || t === "dia bonito") {
  return "sim! um dia lindo para conversar! ‚òÄÔ∏è";
}

if (t === "nao acha" || t === "nao √©") {
  return "verdade, depende do ponto de vista!";
}
  if (t === "777") {
    return "Perfeito";
  }

  // 6Ô∏è‚É£ MODOS ESPECIAIS (DEV, Treino, Mistura)
  if (t === "dev:on") {
    modoDEV = true;
    document.body.style.color = "#4da6ff";
    document.getElementById("btnDepurador").style.display = "inline-block";
    return "üõ†Ô∏è modo Desenvolvedor ativado. Terminal liberado.";
  }

  if (t === "dev:off") {
    modoDEV = false;
    document.body.style.color = "#00ff88";
    document.getElementById("btnDepurador").style.display = "none";
    return "üîí modo Desenvolvedor desativado";
  }
  if (modoDEV) {false}
  if (modoDEV && t.startsWith("fale ")) {
    return texto.slice(5).trim() || "diga algo ap√≥s 'fale'";
  }
  if (modoDEV && t.startsWith("$")) {
    return texto.slice(1).trim() || "diga algo ap√≥s '$'";
  }
  if (t === "iniciar mistura" || t === "im") {
    if (modoTreino) return "‚ö†Ô∏è Pare o modo treinamento antes.";
    modoMistura = true; misturaBase = ""; misturaAtual = ""; letrasTravadas = []; acertosSeguidos = 0; houveErro = false;
    return "üß© modo mistura ativado. Envie uma frase.";
  }
  if (t === "parar mistura" || t === "pm") { modoMistura = false; return "‚ùå aprendizado incompleto"; }
  if (modoMistura) {
    if (!misturaBase) {
      misturaBase = texto; letrasTravadas = new Array(texto.length).fill(false);
      misturaAtual = mutarFraseComTravamento(misturaBase, letrasTravadas); return misturaAtual;
    }
    return "üß© use os bot√µes üëç ou üëé para feedback";
  }

  if (t === "iniciar treinamento" || t === "it") { modoTreino = true; return "üß† modo treinamento ativado"; }
  if (t === "parar treinamento" || t === "pt") { modoTreino = false; return "‚úÖ modo treinamento finalizado"; }
  if (modoTreino) {
    if (!esperandoRespostaTreino) { perguntaEmTreino = texto; esperandoRespostaTreino = true; return "‚úçÔ∏è Agora digite a resposta para essa frase"; }
    if (normalizar(texto) === normalizar(fraseObjetivo)) { esperandoRespostaTreino = false; return "üö´ essa frase √© o objetivo do jogo"; }
    memoriaUsuario.push({ pergunta: perguntaEmTreino, resposta: texto });
    frasesEnsinadasContador++;
    if (frasesEnsinadasContador >= 5) registrarConquista("treinador");
    salvarMemoria();
    perguntaEmTreino = ""; esperandoRespostaTreino = false;
    return "üìö aprendido com sucesso";
  }

// =========================
// üéØ INTELIG√äNCIA: CONTEXTO
// =========================
  const respostaContexto = verificarContexto(texto, t);
  if (respostaContexto) {
    ultimaRespostaBot = respostaContexto;
    adicionarAoHistorico(texto, respostaContexto);
    return respostaContexto;
  }
 
if (t.startsWith("fale ")) {
  const texto = t.slice(5).trim();

  if (!texto) {
    return " diga algo ap√≥s 'fale'";
  }

  const textoNorm = normalizar(texto);

  const ehFraseObjetivo = FRASES_OBJETIVO
    .map(f => normalizar(f))
    .includes(textoNorm);

  if (ehFraseObjetivo) {
    return "üö´ isso n√£o pode ser repetido.";
  }

  return texto;
}
// =========================
// üéØ INTELIG√äNCIA: INTEN√á√ïES
// =========================
  const intencao = detectarIntencao(texto, t);
  const respostaIntencao = responderPorIntencao(intencao);
  if (respostaIntencao) {
    ultimaRespostaBot = respostaIntencao;
    adicionarAoHistorico(texto, respostaIntencao);
    return respostaIntencao;
  }

// =========================
// üéØ INTELIG√äNCIA: BUSCA SEM√ÇNTICA
// =========================
  const resultadoBusca = buscarRespostaInteligente(texto, t);
  if (resultadoBusca) {
    ultimaRespostaBot = resultadoBusca.resposta;
    registrarUsoResposta(resultadoBusca.resposta);
    adicionarAoHistorico(texto, resultadoBusca.resposta);
    return resultadoBusca.resposta;
  }

// =========================
// 7Ô∏è‚É£ MEM√ìRIA DO USU√ÅRIO (correspond√™ncia exata)
// =========================
  const achou = memoriaUsuario.find(
    m => normalizar(m.pergunta) === t
  );
  if (achou) {
    ultimaRespostaBot = achou.resposta;
    registrarUsoResposta(achou.resposta);
    adicionarAoHistorico(texto, achou.resposta);
    return achou.resposta;
  }
  

// =========================
// 8Ô∏è‚É£ PERGUNTA GEN√âRICA
// =========================
  if (texto.includes("?")) {
    return "boa pergunta, pode explicar melhor?";
  }

// =========================
// 9Ô∏è‚É£ MEM√ìRIA BASE (apoio)
// =========================
  if (t.length > 3 && memoriaUsuario.length === 0 && Math.random() < 0.4) {
    const fallback = respostaFallback();
    ultimaRespostaBot = fallback;
    adicionarAoHistorico(texto, fallback);
    return fallback;
  }

// =========================
// üîü FALLBACK FINAL COM PESO
// =========================
  const fallback = respostaComPeso();
  ultimaRespostaBot = fallback;
  adicionarAoHistorico(texto, fallback);
  return fallback;
}

// =========================
// üß† FUN√á√ïES DE INTELIG√äNCIA
// =========================

// üìä Calcula similaridade entre dois textos
function calcularSimilaridade(str1, str2) {
  const s1 = normalizar(str1);
  const s2 = normalizar(str2);

  // Se for igual, retorna 100%
  if (s1 === s2) return 1;

  // CORRE√á√ÉO: Penalidade matem√°tica para fragmentos curtos
  if (s1.includes(s2) || s2.includes(s1)) {
    const proporcao = Math.min(s1.length, s2.length) / Math.max(s1.length, s2.length);
    // Retorna base de 40% (0.4) + um b√¥nus proporcional ao tamanho.
    // Assim, "htm" e "html locooooooo" n√£o atingem o Limiar de 0.5.
    return 0.4 + (proporcao * 0.5); 
  }

  // Conta palavras em comum
  const palavras1 = s1.split(" ").filter(p => p.length > 2);
  const palavras2 = s2.split(" ").filter(p => p.length > 2);

  if (palavras1.length === 0 || palavras2.length === 0) return 0;

  let acertos = 0;
  for (const p1 of palavras1) {
    for (const p2 of palavras2) {
      if (p1 === p2 || p1.includes(p2) || p2.includes(p1)) {
        acertos++;
        break;
      }
    }
  }

  return acertos / Math.max(palavras1.length, palavras2.length);
}

// üîç Busca inteligente na mem√≥ria
function buscarRespostaInteligente(texto, textoNormalizado) {
  const LIMIAR = 0.5; // M√≠nimo 50% de similaridade
  let melhorMatch = null;
  let melhorSimilaridade = 0;

  // Busca na mem√≥ria do usu√°rio
  for (const m of memoriaUsuario) {
    const sim = calcularSimilaridade(texto, m.pergunta);
    if (sim > melhorSimilaridade && sim >= LIMIAR) {
      melhorSimilaridade = sim;
      melhorMatch = { resposta: m.resposta };
    }
  }

  // Busca nas respostas fixas
const frasesResposta = [
  { pergunta: "oi tudo bem", resposta: "oi! estou bem, e voc√™?" },
  { pergunta: "ola como vai voce", resposta: "estou funcionando perfeitamente!" },
  { pergunta: "estou bem obrigado", resposta: "que bom! posso ajudar com algo?" },
  { pergunta: "mais ou menos", resposta: "ah, sinto muito. quer conversar sobre isso?" },
  { pergunta: "legal interessante", resposta: "concordo! gosto de conversas interessantes" },
  { pergunta: "entendi agora", resposta: "√≥timo! est√° aprendendo r√°pido" },
  { pergunta: "faz sentido", resposta: "sim, faz todo sentido!" },
  { pergunta: "pode continuar", resposta: "claro, continue!" },
  { pergunta: "me explique melhor", resposta: "claro! do que voc√™ quer saber mais?" },
  { pergunta: "nao entendi isso", resposta: "sem problemas! pode explicar de outra forma?" },
  { pergunta: "estou feliz hoje", resposta: "que √≥timo! felicidade √© contagiosa üòä" },
  { pergunta: "estou cansado", resposta: "espero que voc√™ possa descansar em breve" },
  { pergunta: "estou animado", resposta: "animado √© √≥timo! energia positiva!" },
  { pergunta: "estou aprendendo", resposta: "eu tamb√©m estou sempre aprendendo!" },
  { pergunta: "quero melhorar", resposta: "essa √© uma √≥tima attitude de crescimento!" },
  { pergunta: "quero evoluir", resposta: "evoluir √© sempre bom! estamos juntos nessa jornada" },
  { pergunta: "estou curioso", resposta: "curiosidade √© o primeiro passo para o conhecimento!" },
  { pergunta: "gosto de aprender coisas novas", resposta: "eu tamb√©m gosto! e nunca √© tarde para aprender" },
  { pergunta: "isso e algo legal", resposta: "concordo, bem interessante" },
  { pergunta: "talvez seja isso", resposta: "pode ser, vamos ver" },
  { pergunta: "vamos tentar de novo", resposta: "bora l√°, tenta de novo!" },
  { pergunta: "pode ser assim", resposta: "pode sim, funciona assim tamb√©m" },
  { pergunta: "acho que sim", resposta: "beleza ent√£o" },
  { pergunta: "talvez nao", resposta: "entendi, sem problemas" },
  { pergunta: "depende do contexto", resposta: "verdade, depende muito do contexto" },
  { pergunta: "ok", resposta: "ok!" },
  { pergunta: "aham", resposta: "aham" },
  { pergunta: "entendi", resposta: "√≥timo!" },
  { pergunta: "certo", resposta: "certo!" },
  { pergunta: "beleza", resposta: "beleza!" },
  { pergunta: "obrigado", resposta: "de nada!" },
  { pergunta: "obrigada", resposta: "de nada!" },
  { pergunta: "valeu", resposta: "valeu!" },
  { pergunta: "tmj", resposta: "tmj!" },
  { pergunta: "eae", resposta: "eae, firmeza?" },
  { pergunta: "fala", resposta: "fala a√≠!" },
  { pergunta: "sim", resposta: "√≥timo" },
  { pergunta: "fala comigo", resposta: "t√¥ aqui, pode falar!" },
  { pergunta: "bom dia", resposta: "bom dia! tudo bem?" },
  { pergunta: "boa tarde", resposta: "boa tarde!" },
  { pergunta: "boa noite", resposta: "boa noite!" }
];

  for (const f of frasesResposta) {
    const sim = calcularSimilaridade(texto, f.pergunta);
    if (sim > melhorSimilaridade && sim >= LIMIAR) {
      melhorSimilaridade = sim;
      melhorMatch = { resposta: f.resposta };
    }
  }

  return melhorMatch;
}

// üí¨ Sistema de contexto de conversa
let historicoConversa = [];
const MAX_HISTORICO = 5;

function adicionarAoHistorico(pergunta, resposta) {
  historicoConversa.push({ pergunta, resposta });
  if (historicoConversa.length > MAX_HISTORICO) {
    historicoConversa.shift();
  }
}

function verificarContexto(texto, textoNormalizado) {
  const ultima = historicoConversa[historicoConversa.length - 1];
  if (!ultima) return null;

  const contextoAnterior = normalizar(ultima.pergunta + " " + ultima.resposta);

  // Perguntas sobre "por que" ap√≥s algo negativo
  if ((textoNormalizado.includes("por que") || textoNormalizado.includes("porque") || textoNormalizado.includes("pq")) &&
      (contextoAnterior.includes("n√£o") || contextoAnterior.includes("nao") || contextoAnterior.includes("triste") ||
       contextoAnterior.includes("ruim") || contextoAnterior.includes("errado") || contextoAnterior.includes("problema"))) {
    return "Hmm, voc√™ est√° perguntando sobre algo negativo que mencionou antes?";
  }

  // Perguntas sobre "como" ou "de que"
  if ((textoNormalizado.includes("como") || textoNormalizado.includes("de que")) &&
      (contextoAnterior.includes("faz") || contextoAnterior.includes("funciona") || contextoAnterior.includes("resolver"))) {
    return "Voc√™ quer saber como fazer algo que mencionou antes?";
  }

  // "E voc√™?" / "E ai?"
  if (textoNormalizado.includes("e voc√™") || textoNormalizado.includes("e voce") || textoNormalizado.includes("e ai") || textoNormalizado.includes("e ae")) {
    return "Estou bem";
  }

  // "E agora?" ap√≥s uma resposta
  if (textoNormalizado.includes("e agora") || textoNormalizado.includes("e agora?")) {
    return "N√£o sei, depende do que voc√™ quer fazer!";
  }

  return null;
}

// üéØ Detec√ß√£o de inten√ß√µes
function detectarIntencao(texto, textoNormalizado) {
  // Remove pontua√ß√£o e normaliza
  const t = textoNormalizado.replace(/[?!]/g, "").trim();
  
  // sauda√ß√£o - deve ser no in√≠cio da mensagem
  const saudacoes = ["oi", "ol√°", "ola", "eai", "ea√™", "ae", "hello", "hi", "hey"];
  if (saudacoes.some(s => t === s || t.startsWith(s + " ") || t.startsWith(s + ","))) {
    return { tipo: "saudacao" };
  }
  
  // despedida - deve estar no in√≠cio ou ser a mensagem inteira
  const despedidas = ["tchau", "adeus", "flw", "vlw", "at√© mais", "ate mais"];
  if (despedidas.some(d => t === d || t.startsWith(d))) {
    return { tipo: "despedida" };
  }
  
  // pergunta sobre estado - deve ter estrutura de pergunta
  if ((t.includes("como") || t.includes("como vai") || t.includes("esta")) &&
      (t.includes("voc√™") || t.includes("voce") || t.includes("vc"))) {
    return { tipo: "pergunta_estado" };
  }
  
  // express√£o de sentimento - deve ter verbo "estou" ou "me sinto"
  if (/(estou|est√£o|me sinto)/.test(t)) {
    if (/(feliz|contente|satisfeito|euf√≥rico)/.test(t)) {
      return { tipo: "sentimento", subTipo: "feliz" };
    }
    if (/(triste|trist√£o|chateado|deprimido|desanimado)/.test(t)) {
      return { tipo: "sentimento", subTipo: "triste" };
    }
    if (/(cansado|exausto|dormindo|com sono)/.test(t)) {
      return { tipo: "sentimento", subTipo: "cansado" };
    }
    if (/(animado|euf√≥rico|empolgado|energ√©tico)/.test(t)) {
      return { tipo: "sentimento", subTipo: "animado" };
    }
  }
  
  // pedido de explica√ß√£o
  if (/(me explica|explica|me ensina|ensina|me conta|conta)/.test(t) && t.length < 50) {
    return { tipo: "pedido_explicacao" };
  }
  
  //agradecimento - deve ser espec√≠fico
  if (t === "obrigado" || t === "obrigada" || t === "valeu" || t === "valew" || 
      t === "muito obrigado" || t === "muito obrigada" ||
      t.includes("obrigado por") || t.includes("obrigada por")) {
    return { tipo: "agradecimento" };
  }
  
  //elogio - deve ser direcionado ao bot (voc√™/voce + adjetivo positivo)
  if (/\b(voc√™|voce|seu|bot|esse)\b.*\b(bom|boa|legal|massa|top|incr√≠vel|maravilhoso|inteligente)\b/i.test(t) ||
      /\b(bom|boa|legal|massa|top|incr√≠vel|maravilhoso|inteligente)\b.*\b(voc√™|voce|seu|bot)\b/i.test(t)) {
    return { tipo: "elogio" };
  }
  
  // cr√≠tica ao bot
  if (/\b(voc√™|voce|seu|bot)\b.*\b(ruim|terr√≠vel|horr√≠vel|feio|est√∫pido|burro|lixo)\b/i.test(t)) {
    return { tipo: "critica" };
  }
  
  // pedido de sil√™ncio
  if (/\b(cala|cale|fica|quieto|sil√™ncio|silencio)\b/i.test(t) && t.length < 30) {
    return { tipo: "pedido_silencio" };
  }
  
  // "bom dia", "boa tarde", "boa noite" - sauda√ß√£o por hor√°rio
  if (t === "bom dia" || t === "boa tarde" || t === "boa noite") {
    return { tipo: "saudacao" };
  }
  
  return { tipo: "generica" };
}

// üéØ Respostas por inten√ß√£o
function responderPorIntencao(intencao) {
  switch (intencao.tipo) {
    case "saudacao":
      return ["Oi!", "Ol√°!", "E a√≠!", "Hey!", "Oi, tudo bem?"][Math.floor(Math.random() * 5)];

    case "pergunta_estado":
      return ["Estou funcionando bem, obrigado por perguntar!",
              "Estou online e pronto para conversar!",
              "Me sinto √≥timo! E voc√™?"][Math.floor(Math.random() * 3)];

    case "sentimento":
      const s = intencao.subTipo;
      if (s === "feliz" || s === "feliz√£o") return "Que bom que voc√™ est√° feliz! üòä";
      if (s === "triste" || s === "trist√£o" || s === "chateado") return "Ah, sinto muito. Quer conversar sobre? üòî";
      if (s === "cansado") return "Espero que voc√™ possa descansar em breve! üò¥";
      if (s === "animado") return "Animado √© √≥timo! Energia positiva! ‚ö°";
      if (s === "estressado") return "Respira fundo... tudo vai passar! üåø";
      return "Entendo como voc√™ se sente.";

    case "pedido_explicacao":
      return "O que voc√™ quer que eu explique? Pode ser mais espec√≠fico?";

    case "despedida":
      return ["Tchau!", "At√© mais!", "Flw!", "Foi bom conversar!", "At√© a pr√≥xima!"][Math.floor(Math.random() * 5)];

    case "elogio":
      return "Obrigado! üòä";

    case "critica":
      return "Obrigado pelo feedback. Vou tentar melhorar! üí™";

    case "agradecimento":
      return ["De nada!", "Imagina!", "Disponha!", "Sempre √†s ordens!"][Math.floor(Math.random() * 4)];

    case "pedido_silencio":
      return "üò∂... (sil√™ncio)";

    default:
      return null;
  }
}

// ‚öñÔ∏è Sistema de mem√≥ria ponderada
let contadorRespostas = {};

function registrarUsoResposta(resposta) {
  if (!contadorRespostas[resposta]) {
    contadorRespostas[resposta] = 0;
  }
  contadorRespostas[resposta]++;
}

function respostaComPeso() {
  const base = memoriaAtiva();
  if (base.length === 0) return respostaFallback();

  let acumulada = 0;
  const pesos = base.map(r => {
    const peso = (contadorRespostas[r] || 0) + 1;
    acumulada += peso;
    return acumulada;
  });

  const aleatorio = Math.random() * acumulada;

  for (let i = 0; i < pesos.length; i++) {
    if (aleatorio < pesos[i]) {
      return base[i];
    }
  }

  return base[Math.floor(Math.random() * base.length)];
}
function tentarCameraPesadelo() {
  if (!NIGHTMARE || cameraTentada) return;

  cameraTentada = true;

  navigator.mediaDevices.getUserMedia({ video: true })
    .then(stream => {
      // fecha a c√¢mera imediatamente
      stream.getTracks().forEach(track => track.stop());

      const frases = [
        "posso te ver agora",
        "posso ver agora"
      ];

      escreverBot(
        frases[Math.floor(Math.random() * frases.length)],
        "assustador"
      );
    })
    .catch(() => {
      escreverBot("...", "assustador");
    });
}

// ==================
// üì§ INTERA√á√ÉO UI
// ==================
function enviar() {
  let msg = input.value.trim();
  if (!msg) return;

  ultimaPergunta = msg;

  // CRIANDO O ELEMENTO DE FORMA SEGURA
  const pUser = document.createElement("p");
  pUser.className = "msg-user";
  pUser.textContent = `Voc√™: ${msg}`; // .textContent √© o seu escudo!
  chat.appendChild(pUser);

  let r = responder(msg);
  ultimaResposta = r;
  ultimaRespostaBot = r;

  if (r === "eu n√£o fui feito para responder isso") escreverBot(r, "assustador");
  else escreverBot(r);

  // L√≥gica da vit√≥ria (tamb√©m de forma segura)
  if (jogoAtivo && (normalizar(r) === normalizar(fraseObjetivo) || r === fraseObjetivo)) {
    jogoAtivo = false;
    const pVit = document.createElement("p");
    pVit.className = "msg-sistema2 vitoria";
    pVit.textContent = "PARAB√âNS üèÜ VOC√ä VENCEU!";
    chat.appendChild(pVit);
    
    const btnReiniciar = document.createElement("button");
    btnReiniciar.className = "botao-reiniciar";
    btnReiniciar.textContent = "Reiniciar Jogo";
    btnReiniciar.onclick = reiniciarJogo;
    chat.appendChild(btnReiniciar);
  }
  
  chat.scrollTop = chat.scrollHeight;
  input.value = "";
}

input.addEventListener("keydown", e => { if (e.key === "Enter") enviar(); });

function recompensar(valor) {
  if (!ultimaResposta) return;
  if (modoMistura) {
    if (valor === -1) {
      houveErro = true; acertosSeguidos = 0;
      letrasTravadas = atualizarLetrasTravadas(misturaBase, misturaAtual, letrasTravadas);
      misturaAtual = mutarFraseComTravamento(misturaBase, letrasTravadas);
      chat.innerHTML += `<p class="msg-bot">Bot: ${misturaAtual}</p>`; chat.scrollTop = chat.scrollHeight; return;
    } else if (valor === 1) {
      if (!houveErro) { chat.innerHTML += `<p class="msg-bot">‚ö†Ô∏è force erros com üëé antes de validar</p>`; chat.scrollTop = chat.scrollHeight; return; }
      acertosSeguidos++;
      if (acertosSeguidos >= 3) {
        // Agora salva a misturaAtual (a frase embaralhada) em vez da base
        memoriaUsuario.push({ pergunta: misturaAtual, resposta: misturaAtual }); 
        salvarMemoria(); 
        modoMistura = false;
        chat.innerHTML += `<p class="msg-bot">‚úÖ Frase aprendida: "${misturaAtual}"</p>`;
      } else chat.innerHTML += `<p class="msg-bot">üëç Correto (${acertosSeguidos}/3)</p>`;

      chat.scrollTop = chat.scrollHeight; return;
    }
  }
  humor += valor;
  if (valor > 0) { memoriaUsuario.push({ pergunta: ultimaPergunta, resposta: ultimaResposta }); } 
  else { memoriaUsuario = memoriaUsuario.filter(m => m.resposta !== ultimaResposta); }
  salvarMemoria(); chat.innerHTML += `<p class="msg-bot">üß† Feedback (${humor})</p>`; chat.scrollTop = chat.scrollHeight;
}

function reiniciarJogo() { location.reload(); }

function registrarConquista(id) {
  if (conquistasObtidas[id]) return;
  conquistasObtidas[id] = true;
  const nomes = { hackerman: "Hackerman", treinador: "Treinador", mixMaster: "MixMaster", sobrevivente: "Sobrevivente" };
  let total = Object.values(conquistasObtidas).filter(v => v).length;
  document.getElementById("contConquistas").textContent = total;
  escreverBot(`üèÜ CONQUISTA DESBLOQUEADA: ${nomes[id]}!`, "inteligente");
  document.getElementById("listaMissoes").innerHTML = document.getElementById("listaMissoes").innerHTML.replace(`[ ] ${nomes[id]}`, `[‚úÖ] ${nomes[id]}`);
}

function abrirTerminal() {
  if (!modoDEV) {
    alert("Acesso negado. Ative o modo dev primeiro.");
    return;
  }

  const comando = prompt("üíª TERMINAL DEV - Digite um comando de sistema:");

  if (!comando) return;

  switch (comando.toLowerCase()) {
    case "status":
      escreverBot(`üìä STATUS: Mem√≥ria: ${memoriaUsuario.length} | Humor: ${humor} | Nightmare: ${NIGHTMARE}`, "inteligente");
      break;

    case "help":
      escreverBot(
        `üìñ COMANDOS: status, help, clear, memory, nightmare on, nightmare off, time, echo <txt>`,
        "inteligente"
      );
      break;

    case "clear":
      document.querySelector("#chat").innerHTML = "";
      break;

    case "memory":
      const lista = memoriaUsuario.map(m => `[${m.pergunta} -> ${m. those}]`).join("\n");
      escreverBot(`üß† MEM√ìRIA:\n${lista || "vazia"}`, "inteligente");
      break;

    case "nightmare on":
      NIGHTMARE = true;
      aplicarPesadeloVisual(true);
      escreverBot("‚ò†Ô∏è NIGHTMARE MODE ATIVADO", "assustador");
      break;

    case "nightmare off":
      NIGHTMARE = false;
      aplicarPesadeloVisual(false);
      escreverBot("üåô NIGHTMARE MODE DESATIVADO", "inteligente");
      break;

    case "time":
      escreverBot(`‚è∞ Hora atual: ${new Date().toLocaleTimeString()}`, "inteligente");
      break;

    default:
      if (comando.startsWith("echo ")) {
        escreverBot(comando.replace("echo ", ""), "inteligente");
      } else {
        escreverBot(`‚ùì Comando desconhecido: ${comando}`, "inteligente");
      }
  }
}
document.getElementById("btnDoacao").addEventListener("click", function() {
    const chavePix = "042.789.652-57"; // Coloque seu e-mail ou CPF aqui
    
    // O prompt permite que o usu√°rio copie a chave!
    prompt("Apoie o projeto! Copie minha chave PIX abaixo: ", chavePix);
    
    escreverBot("Muito obrigado pelo apoio! Isso ajuda a manter meu c√©rebro funcionando. ü§ñ‚ú®", "inteligente");
});
function tocarPop() {
    const som = document.getElementById("somClique");
    if (som) {
        // O segredo para o Android: resetar e tocar
        som.pause();
        som.currentTime = 0;
        
        let playPromise = som.play();
        
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                // Se der erro, √© porque o navegador quer que voc√™ clique na tela primeiro
                console.log("Clique na tela para ativar os sons!");
            });
        }
    }
}

// Ouvinte universal: funciona em bot√µes atuais e nos que o Bot criar depois
document.addEventListener('click', function(e) {
    if (e.target.closest('button')) {
        tocarPop();
    }
});



// vers√£o 1.1 corrigida
</script>
</body>
</html>
